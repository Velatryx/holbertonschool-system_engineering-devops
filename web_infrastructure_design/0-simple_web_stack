This is a high-level design of a minimal one-server web infrastructure powering the website www.foobar.com
. The goal is to show how each piece works together, starting from the moment a user tries to access the site.

How a User Reaches the Website

A user enters www.foobar.com
 in their browser.

The browser asks DNS to translate that name into an IP address.

DNS replies with 8.8.8.8, which is the public IP of our server.

The browser connects to that server over HTTP/HTTPS.

The server receives the request, the web server routes it, the application server handles the logic, and the database provides the needed data before a response is returned to the user.

Infrastructure Components:

1. Domain name
A domain name makes the website easy for humans to reach. Instead of remembering an IP address like 8.8.8.8, users simply type www.foobar.com
.
It’s managed through DNS, which maps names to IPs.

2. DNS record
The www in www.foobar.com
 is configured as an A record, meaning it points the hostname directly to an IPv4 address — here, 8.8.8.8.

3. Server
This setup uses just one server. It can be a physical machine or a cloud instance, but it has one job: run all components of the stack.
The server hosts:

Nginx (web server)

Application server;

Application code;

MySQL database;

4. Web Server (Nginx)
Nginx is the first piece that receives incoming web traffic.
Its role:

Serve static content quickly (HTML, CSS, images);

Forward dynamic requests to the application server;
It essentially acts as the “front door” of the infrastructure.

5. Application Server

This is where the logic of the website actually runs.
It:

Executes backend code;
Handles routes, authentication, and business logic;
Connects to the database to retrieve or save data;
The application server produces the dynamic responses that Nginx returns to the user.

6. Appliction Files (Code Base)
This is the website’s actual code — the backend scripts, templates, and all logic that powers the application.

7. Database (MySQL)
MySQL stores the structured data the application needs — users, orders, posts, sessions, and so on.
The application server interacts with it using SQL queries.

8. Communication With the User
The user’s browser and the server communicate using HTTP/HTTPS, transported over TCP/IP.

Weaknesses of This Architecture:

1. Single Point of Failure
Since everything lives on one server, if that server goes offline for any reason — hardware failure, OS crash, accidental deletion — the entire website becomes unreachable.

2. Maintenance Leads to Downtime
Updates to the application, server restarts, security patches, or database maintenance all interrupt service.
With no secondary server, even routine tasks cause outages.

3. No Ability to Scale
If traffic suddenly increases, this server has no backup to share the load.
!Once CPU, memory, or bandwidth maxes out:
the site slows down, requests time out, and the server may fully crash.
